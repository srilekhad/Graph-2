// Time Complexity: O(n^2) – process the adjacency matrix (near-constant-time DSU ops), plus O(n) scans for sizes and selections.
// Space Complexity: O(n) – DSU parent array + component size array + infected-per-component array.

// Union-Find all connected nodes by scanning the adjacency matrix; this forms components.
// Count each component’s size and how many initially infected it contains.
// Pick the infected node whose component has exactly one infected and is largest (saves most nodes); break ties by smaller index; if none, return the smallest index in initial.

class Solution {
    int[] parent;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int n = graph.length;
        this.parent = new int[n];

        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    union(i, j);
                }
            }
        }

        int[] groups = new int[n]; // group size for each root
        for (int i = 0; i < n; i++) {
            int root = find(i);
            groups[root]++;
        }

        int[] infctd = new int[n]; // infected node count per group
        for (int node : initial) {
            int root = find(node);
            infctd[root]++;
        }

        int result = Integer.MAX_VALUE;
        for (int node : initial) {
            int gr = find(node);

            if (infctd[gr] == 1) {
                if (result == Integer.MAX_VALUE) {
                    result = node;
                } else if (groups[gr] > groups[find(result)]) {
                    result = node;
                } else if (groups[gr] == groups[find(result)]) {
                    result = Math.min(result, node);
                }
            }
        }

        if (result == Integer.MAX_VALUE) {
            for (int node : initial) {
                result = Math.min(result, node);
            }
        }

        return result;
    }

    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    private void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px != py) {
            parent[px] = py;
        }
    }
}
